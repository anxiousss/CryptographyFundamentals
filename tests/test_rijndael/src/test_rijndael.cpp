#include "test_rijndael.hpp"
#include <iostream>
#include <chrono>
#include <random>
#include <cassert>
#include <filesystem>
#include <iomanip>
#include <functional>
#include <bitset>

std::string polynomial_to_string(std::byte poly) {
    std::stringstream ss;
    uint8_t poly_value = std::to_integer<uint8_t>(poly);
    ss << "0x" << std::hex << std::setw(2) << std::setfill('0')
       << std::uppercase << (int)poly_value;

    std::bitset<8> bits(poly_value);

    std::string poly_str = ss.str() + " (x^8";

    for (int i = 7; i >= 0; i--) {
        if (bits[i]) {
            if (i == 1) {
                poly_str += " + x";
            } else if (i == 0) {
                poly_str += " + 1";
            } else {
                poly_str += " + x^" + std::to_string(i);
            }
        }
    }
    poly_str += ")";

    return poly_str;
}


std::vector<PolynomialConfig> get_available_polynomials() {
    std::vector<PolynomialConfig> configs;

    try {
        if (galois_fields::polynomials[8].empty()) {
            galois_fields::GaloisField::find_irreducible_polynomials();
        }

        const auto& polys_8 = galois_fields::polynomials[8];

        if (polys_8.empty()) {
            std::cout << "Warning: No irreducible polynomials found for degree 8. "
                      << "Using default AES polynomial." << std::endl;

            PolynomialConfig default_poly;
            default_poly.polynomial = std::byte{0x1B};
            default_poly.index = 0;
            default_poly.name = polynomial_to_string(default_poly.polynomial);
            configs.push_back(default_poly);

            return configs;
        }

        std::cout << "Found " << polys_8.size()
                  << " irreducible polynomials of degree 8 from Galois fields" << std::endl;

        for (size_t i = 0; i < polys_8.size(); ++i) {
            PolynomialConfig config;
            config.polynomial = polys_8[i];
            config.index = i;
            config.name = polynomial_to_string(config.polynomial);

            configs.push_back(config);
        }
    } catch (const std::exception& e) {
        std::cout << "Error getting irreducible polynomials from Galois fields: "
                  << e.what() << std::endl;

        PolynomialConfig default_poly;
        default_poly.polynomial = std::byte{0x1B};
        default_poly.index = 0;
        default_poly.name = polynomial_to_string(default_poly.polynomial);
        configs.push_back(default_poly);
    }

    return configs;
}

void print_available_polynomials() {
    auto polynomials = get_available_polynomials();

    std::cout << "\n=== Available Irreducible Polynomials (degree 8) ===" << std::endl;
    std::cout << "Generated by Galois fields module" << std::endl;
    std::cout << "Index | Hex Value | Polynomial Representation" << std::endl;
    std::cout << "------|-----------|---------------------------" << std::endl;

    for (size_t i = 0; i < polynomials.size(); ++i) {
        const auto& poly = polynomials[i];

        std::string hex_value;
        size_t start = poly.name.find("0x");
        if (start != std::string::npos) {
            size_t end = poly.name.find(" ", start);
            if (end != std::string::npos) {
                hex_value = poly.name.substr(start, end - start);
            } else {
                hex_value = poly.name.substr(start);
            }
        } else {
            hex_value = "N/A";
        }

        std::cout << std::setw(5) << i << " | "
                  << std::setw(9) << hex_value << " | ";

        size_t poly_start = poly.name.find("(");
        if (poly_start != std::string::npos) {
            std::cout << poly.name.substr(poly_start);
        } else {
            std::cout << poly.name;
        }
        std::cout << std::endl;
    }

    std::cout << "\nTotal: " << polynomials.size()
              << " irreducible polynomials available from Galois fields." << std::endl;

    std::cout << "\nVerifying polynomial irreducibility..." << std::endl;
    int verified_count = 0;
    for (const auto& poly : polynomials) {
        try {
            bool is_irreducible = galois_fields::GaloisField::is_polynom_irreducible(poly.polynomial);
            if (is_irreducible) {
                verified_count++;
                std::cout << "  ✓ " << poly.name << std::endl;
            } else {
                std::cout << "  ✗ " << poly.name << " is NOT irreducible (should not happen!)" << std::endl;
            }
        } catch (const std::exception& e) {
            std::cout << "  ? " << poly.name << " verification failed: " << e.what() << std::endl;
        }
    }

    if (verified_count == polynomials.size()) {
        std::cout << "\nAll " << verified_count
                  << " polynomials verified as irreducible." << std::endl;
    } else {
        std::cout << "\nWarning: Only " << verified_count << " out of "
                  << polynomials.size() << " polynomials verified as irreducible." << std::endl;
    }
}

void safe_initialize_galois() {
    static bool initialized = false;
    if (!initialized) {
        try {
            galois_fields::GaloisField::find_irreducible_polynomials();

            if (galois_fields::polynomials.find(8) == galois_fields::polynomials.end() ||
                galois_fields::polynomials[8].empty()) {
                std::cout << "Warning: No irreducible polynomials of degree 8 found during initialization." << std::endl;
            } else {
                std::cout << "Galois fields initialized successfully. Found "
                          << galois_fields::polynomials[8].size()
                          << " irreducible polynomials of degree 8." << std::endl;
            }

            initialized = true;
        } catch (const std::exception& e) {
            std::cout << "Error initializing Galois fields: " << e.what() << std::endl;
            initialized = true;
        }
    }
}

std::unique_ptr<symmetric_context::SymmetricAlgorithm> create_rijndael_with_polynomial(
        const std::vector<std::byte>& key,
        size_t block_size,
        const PolynomialConfig& poly_config) {

    safe_initialize_galois();
    std::vector<std::byte> key_copy = key;

    try {
        bool is_irreducible = galois_fields::GaloisField::is_polynom_irreducible(poly_config.polynomial);
        if (!is_irreducible) {
            throw std::invalid_argument("Polynomial " + poly_config.name + " is not irreducible");
        }

        std::cout << "Creating Rijndael with polynomial: " << poly_config.name << std::endl;
        return std::make_unique<rijndael::Rijndael>(key_copy, block_size, poly_config.polynomial);
    } catch (const std::exception& e) {
        std::cerr << "Error creating Rijndael with polynomial " << poly_config.name
                  << ": " << e.what() << std::endl;
        throw;
    }
}

std::unique_ptr<symmetric_context::SymmetricAlgorithm> create_aes_128_with_polynomial(
        const std::vector<std::byte>& key,
        const PolynomialConfig& poly_config) {

    if (key.size() != 16) {
        throw std::invalid_argument("Key size must be 16 bytes for AES-128");
    }

    return create_rijndael_with_polynomial(key, 16, poly_config);
}

std::unique_ptr<symmetric_context::SymmetricAlgorithm> create_aes_192_with_polynomial(
        const std::vector<std::byte>& key,
        const PolynomialConfig& poly_config) {

    if (key.size() != 24) {
        throw std::invalid_argument("Key size must be 24 bytes for AES-192");
    }

    return create_rijndael_with_polynomial(key, 16, poly_config);
}

std::unique_ptr<symmetric_context::SymmetricAlgorithm> create_aes_256_with_polynomial(
        const std::vector<std::byte>& key,
        const PolynomialConfig& poly_config) {

    if (key.size() != 32) {
        throw std::invalid_argument("Key size must be 32 bytes for AES-256");
    }

    return create_rijndael_with_polynomial(key, 16, poly_config);
}

void RijndaelTest::initialize_galois_fields() {
    safe_initialize_galois();
}

bool RijndaelTest::test_rijndael_file_with_polynomial(
        const std::string& file_type,
        const std::filesystem::path& file_path,
        const std::vector<std::byte>& key,
        const std::vector<std::byte>& iv,
        const PolynomialConfig& poly_config,
        const std::string& algorithm_name) {

    if (!std::filesystem::exists(file_path)) {
        std::cout << "File not found: " << file_path << std::endl;
        return false;
    }

    try {
        auto algorithm = create_aes_128_with_polynomial(key, poly_config);
        symmetric_context::SymmetricContext cipher(
                key,
                get_file_encryption_mode(),
                get_file_padding_mode(),
                iv, {},
                std::move(algorithm)
        );

        std::string file_stem = file_path.stem().string();
        std::filesystem::path results_dir = "tests/test_rijndael/results";
        std::filesystem::create_directories(results_dir);

        std::string hex_value;
        size_t start = poly_config.name.find("0x");
        if (start != std::string::npos) {
            size_t end = poly_config.name.find(" ", start);
            if (end != std::string::npos) {
                hex_value = poly_config.name.substr(start + 2, end - start - 2);
            } else {
                hex_value = poly_config.name.substr(start + 2);
            }
        } else {
            hex_value = std::to_string(poly_config.index);
        }

        std::string poly_tag = "poly_" + hex_value;
        std::filesystem::path encrypted_path = results_dir /
                                               (file_stem + "_" + algorithm_name + "_" + poly_tag + "_encrypted" + file_path.extension().string());
        std::filesystem::path decrypted_path = results_dir /
                                               (file_stem + "_" + algorithm_name + "_" + poly_tag + "_decrypted" + file_path.extension().string());

        std::cout << "Testing " << file_type << " file with " << algorithm_name
                  << " (Polynomial: " << poly_config.name << "):" << std::endl;
        std::cout << "  Original: " << file_path << std::endl;
        std::cout << "  Encrypted: " << encrypted_path << std::endl;
        std::cout << "  Decrypted: " << decrypted_path << std::endl;

        auto encrypt_start = std::chrono::high_resolution_clock::now();
        std::optional<std::filesystem::path> opt_encrypted = encrypted_path;
        cipher.encrypt(file_path, opt_encrypted).get();
        auto encrypt_end = std::chrono::high_resolution_clock::now();
        auto encrypt_duration = std::chrono::duration_cast<std::chrono::milliseconds>(encrypt_end - encrypt_start);

        auto decrypt_start = std::chrono::high_resolution_clock::now();
        std::optional<std::filesystem::path> opt_decrypted = decrypted_path;
        cipher.decrypt(encrypted_path, opt_decrypted).get();
        auto decrypt_end = std::chrono::high_resolution_clock::now();
        auto decrypt_duration = std::chrono::duration_cast<std::chrono::milliseconds>(decrypt_end - decrypt_start);

        auto original_size = std::filesystem::file_size(file_path);
        auto encrypted_size = std::filesystem::file_size(encrypted_path);
        auto decrypted_size = std::filesystem::file_size(decrypted_path);

        print_file_metrics(file_type + " File (" + algorithm_name + ", Poly: " + poly_config.name + ")",
                           original_size, encrypted_size, decrypted_size,
                           encrypt_duration, decrypt_duration);

        bool success = compare_files(file_path, decrypted_path);

        if (success) {
            std::cout << "✓ " << file_type << " file encryption/decryption successful with polynomial "
                      << poly_config.name << std::endl;
        } else {
            std::cout << "✗ " << file_type << " file encryption/decryption failed with polynomial "
                      << poly_config.name << std::endl;
        }

        return success;

    } catch (const std::exception& e) {
        std::cout << "Exception in " << file_type << " file test (Poly: " << poly_config.name
                  << "): " << e.what() << std::endl;
        return false;
    }
}

void RijndaelTest::test_basic_modes_with_function(
        const std::vector<std::byte>& key,
        const std::vector<std::byte>& iv,
        std::function<std::unique_ptr<symmetric_context::SymmetricAlgorithm>(const std::vector<std::byte>&)> create_algorithm,
        const std::string& algorithm_name) {

    std::vector<symmetric_context::EncryptionModes> modes = {
            symmetric_context::EncryptionModes::ECB,
            symmetric_context::EncryptionModes::CBC,
            symmetric_context::EncryptionModes::PCBC,
            symmetric_context::EncryptionModes::CFB,
            symmetric_context::EncryptionModes::OFB,
            symmetric_context::EncryptionModes::CTR,
            symmetric_context::EncryptionModes::RandomDelta
    };

    std::vector<std::byte> test_data = {
            std::byte{0x11}, std::byte{0x22}, std::byte{0x33}, std::byte{0x44},
            std::byte{0x55}, std::byte{0x66}, std::byte{0x77}, std::byte{0x88},
            std::byte{0x99}, std::byte{0xAA}, std::byte{0xBB}, std::byte{0xCC},
            std::byte{0xDD}, std::byte{0xEE}, std::byte{0xFF}, std::byte{0x00}
    };

    bool all_passed = true;

    for (auto mode : modes) {
        std::string mode_name;
        switch (mode) {
            case symmetric_context::EncryptionModes::ECB: mode_name = "ECB"; break;
            case symmetric_context::EncryptionModes::CBC: mode_name = "CBC"; break;
            case symmetric_context::EncryptionModes::PCBC: mode_name = "PCBC"; break;
            case symmetric_context::EncryptionModes::CFB: mode_name = "CFB"; break;
            case symmetric_context::EncryptionModes::OFB: mode_name = "OFB"; break;
            case symmetric_context::EncryptionModes::CTR: mode_name = "CTR"; break;
            case symmetric_context::EncryptionModes::RandomDelta: mode_name = "RandomDelta"; break;
        }

        try {
            auto algorithm = create_algorithm(key);
            std::optional<std::vector<std::byte>> opt_iv = (mode != symmetric_context::EncryptionModes::ECB)
                                                           ? std::make_optional(iv) : std::nullopt;

            symmetric_context::SymmetricContext algo(key, mode, symmetric_context::PaddingModes::PKCS7,
                                                     opt_iv, {}, std::move(algorithm));

            auto encrypted = algo.encrypt(test_data).get();
            auto decrypted = algo.decrypt(encrypted).get();

            if (!compare_byte_vectors(test_data, decrypted)) {
                std::cout << "✗ " << mode_name << " mode failed for " << algorithm_name << std::endl;
                all_passed = false;
            } else {
                std::cout << "✓ " << mode_name << " mode passed for " << algorithm_name << std::endl;
            }
        } catch (const std::exception& e) {
            std::cout << "✗ " << mode_name << " mode exception for " << algorithm_name
                      << ": " << e.what() << std::endl;
            all_passed = false;
        }
    }

    if (all_passed) {
        std::cout << "✓ All encryption modes passed for " << algorithm_name << std::endl;
    } else {
        std::cout << "✗ Some encryption modes failed for " << algorithm_name << std::endl;
    }
}

void RijndaelTest::test_padding_modes_with_function(
        const std::vector<std::byte>& key,
        const std::vector<std::byte>& iv,
        std::function<std::unique_ptr<symmetric_context::SymmetricAlgorithm>(const std::vector<std::byte>&)> create_algorithm,
        const std::string& algorithm_name) {

    std::vector<std::vector<std::byte>> test_data_sets = {
            {std::byte{0x11}, std::byte{0x22}, std::byte{0x33}, std::byte{0x44}},
            {std::byte{0x11}, std::byte{0x22}, std::byte{0x33}, std::byte{0x44},
                    std::byte{0x55}, std::byte{0x66}, std::byte{0x77}, std::byte{0x88}},
            {std::byte{0x11}, std::byte{0x22}, std::byte{0x33}, std::byte{0x44},
                    std::byte{0x55}, std::byte{0x66}, std::byte{0x77}, std::byte{0x88},
                    std::byte{0x99}, std::byte{0xAA}, std::byte{0xBB}, std::byte{0xCC}}
    };

    std::vector<symmetric_context::PaddingModes> padding_modes = {
            symmetric_context::PaddingModes::ANSIX_923,
            symmetric_context::PaddingModes::PKCS7,
            symmetric_context::PaddingModes::ISO_10126
    };

    bool all_passed = true;

    for (auto padding_mode : padding_modes) {
        for (const auto& test_data : test_data_sets) {
            try {
                auto algorithm = create_algorithm(key);
                symmetric_context::SymmetricContext algo(key, symmetric_context::EncryptionModes::CBC, padding_mode,
                                                         iv, {}, std::move(algorithm));

                auto encrypted = algo.encrypt(test_data).get();
                auto decrypted = algo.decrypt(encrypted).get();

                if (!compare_byte_vectors(test_data, decrypted)) {
                    all_passed = false;
                    std::cout << "✗ Padding mode " << static_cast<int>(padding_mode)
                              << " failed for data size " << test_data.size()
                              << " with " << algorithm_name << std::endl;
                } else {
                    std::cout << "✓ Padding mode " << static_cast<int>(padding_mode)
                              << " passed for data size " << test_data.size()
                              << " with " << algorithm_name << std::endl;
                }
            } catch (const std::exception& e) {
                all_passed = false;
                std::cout << "✗ Padding mode " << static_cast<int>(padding_mode)
                          << " threw exception for data size " << test_data.size()
                          << " with " << algorithm_name
                          << ": " << e.what() << std::endl;
            }
        }
    }

    if (all_passed) {
        std::cout << "✓ All padding modes passed for " << algorithm_name << std::endl;
    } else {
        std::cout << "✗ Some padding modes failed for " << algorithm_name << std::endl;
    }
}

void RijndaelTest::test_edge_cases_with_function(
        const std::vector<std::byte>& key,
        std::function<std::unique_ptr<symmetric_context::SymmetricAlgorithm>(const std::vector<std::byte>&)> create_algorithm,
        const std::string& algorithm_name) {

    bool all_passed = true;

    try {
        std::vector<std::byte> empty_data;
        auto algorithm = create_algorithm(key);
        symmetric_context::SymmetricContext algo(key, symmetric_context::EncryptionModes::ECB,
                                                 symmetric_context::PaddingModes::PKCS7,
                                                 std::nullopt, {}, std::move(algorithm));

        auto encrypted = algo.encrypt(empty_data).get();
        auto decrypted = algo.decrypt(encrypted).get();

        if (!decrypted.empty()) {
            std::cout << "✗ Empty data test failed for " << algorithm_name << std::endl;
            all_passed = false;
        } else {
            std::cout << "✓ Empty data test passed for " << algorithm_name << std::endl;
        }
    } catch (const std::exception& e) {
        std::cout << "✗ Empty data test exception for " << algorithm_name
                  << ": " << e.what() << std::endl;
        all_passed = false;
    }

    try {
        std::vector<std::byte> large_data;
        for (int i = 0; i < 64; ++i) {
            large_data.push_back(static_cast<std::byte>(0x20 + i));
        }

        std::vector<std::byte> iv = {
                std::byte{0xAA}, std::byte{0xBB}, std::byte{0xCC}, std::byte{0xDD},
                std::byte{0xEE}, std::byte{0xFF}, std::byte{0x11}, std::byte{0x22}
        };

        auto algorithm = create_algorithm(key);
        symmetric_context::SymmetricContext algo(key, symmetric_context::EncryptionModes::CBC,
                                                 symmetric_context::PaddingModes::PKCS7,
                                                 iv, {}, std::move(algorithm));

        auto encrypted = algo.encrypt(large_data).get();
        auto decrypted = algo.decrypt(encrypted).get();

        bool data_matches = compare_byte_vectors(large_data, decrypted);
        if (data_matches && large_data.size() == decrypted.size()) {
            std::cout << "✓ Large data test passed for " << algorithm_name << std::endl;
        } else {
            std::cout << "✗ Large data test failed for " << algorithm_name << std::endl;
            all_passed = false;
        }
    } catch (const std::exception& e) {
        std::cout << "✗ Large data test exception for " << algorithm_name
                  << ": " << e.what() << std::endl;
        all_passed = false;
    }

    if (all_passed) {
        std::cout << "✓ All edge cases passed for " << algorithm_name << std::endl;
    } else {
        std::cout << "✗ Some edge cases failed for " << algorithm_name << std::endl;
    }
}

void RijndaelTest::test_aes_128_with_polynomial(const TestFileConfig& config, const PolynomialConfig& poly_config) {
    std::cout << "\n--- Testing AES-128 with Polynomial " << poly_config.name << " ---" << std::endl;

    std::vector<std::byte> key(16);
    for (size_t i = 0; i < 16; ++i) {
        key[i] = static_cast<std::byte>(i + 1);
    }

    std::vector<std::byte> iv(16);
    for (size_t i = 0; i < 16; ++i) {
        iv[i] = static_cast<std::byte>(i + 0x10);
    }

    std::function<std::unique_ptr<symmetric_context::SymmetricAlgorithm>(const std::vector<std::byte>&)> create_algo_func =
            [&poly_config](const std::vector<std::byte>& k) {
                return create_aes_128_with_polynomial(k, poly_config);
            };

    std::string algo_name = "AES-128-poly" + std::to_string(poly_config.index);

    runner.start_test(algo_name + " Basic Encryption Modes");
    try {
        test_basic_modes_with_function(key, iv, create_algo_func, algo_name);
        runner.end_test(true);
    } catch (const std::exception& e) {
        std::cout << "Exception: " << e.what() << std::endl;
        runner.end_test(false);
    }

    runner.start_test(algo_name + " Padding Modes");
    try {
        test_padding_modes_with_function(key, iv, create_algo_func, algo_name);
        runner.end_test(true);
    } catch (const std::exception& e) {
        std::cout << "Exception: " << e.what() << std::endl;
        runner.end_test(false);
    }

    runner.start_test(algo_name + " Edge Cases");
    try {
        test_edge_cases_with_function(key, create_algo_func, algo_name);
        runner.end_test(true);
    } catch (const std::exception& e) {
        std::cout << "Exception: " << e.what() << std::endl;
        runner.end_test(false);
    }

    bool any_file_tested = false;

    auto test_file_if_exists = [&](const std::string& file_type,
                                   const std::filesystem::path& file_path) -> bool {
        if (!file_path.empty() && std::filesystem::exists(file_path)) {
            runner.start_test(algo_name + " " + file_type + " File");
            bool success = test_rijndael_file_with_polynomial(
                    file_type, file_path, key, iv, poly_config, "AES-128"
            );
            runner.assert_true(success, algo_name + " " + file_type + " file should be correctly processed");
            runner.end_test(success);
            any_file_tested = true;
            return success;
        } else if (!file_path.empty()) {
            std::cout << "Note: " << file_type << " file not found: " << file_path << std::endl;
        }
        return false;
    };

    std::cout << "\n--- File Tests ---" << std::endl;
    test_file_if_exists("Text", config.text_file_path);
    test_file_if_exists("Binary", config.binary_file_path);
    test_file_if_exists("Image", config.image_file_path);
    test_file_if_exists("PDF", config.pdf_file_path);
    test_file_if_exists("ZIP", config.zip_file_path);
    test_file_if_exists("MP4", config.mp4_file_path);

    if (!any_file_tested) {
        std::cout << "No test files found. Skipping file tests." << std::endl;
    }
}

void RijndaelTest::test_aes_192_with_polynomial(const TestFileConfig& config, const PolynomialConfig& poly_config) {
    std::cout << "\n--- Testing AES-192 with Polynomial " << poly_config.name << " ---" << std::endl;

    std::vector<std::byte> key(24);
    for (size_t i = 0; i < 24; ++i) {
        key[i] = static_cast<std::byte>(i + 0x20);
    }

    std::vector<std::byte> iv(16);
    for (size_t i = 0; i < 16; ++i) {
        iv[i] = static_cast<std::byte>(i + 0x30);
    }

    std::function<std::unique_ptr<symmetric_context::SymmetricAlgorithm>(const std::vector<std::byte>&)> create_algo_func =
            [&poly_config](const std::vector<std::byte>& k) {
                return create_aes_192_with_polynomial(k, poly_config);
            };

    std::string algo_name = "AES-192-poly" + std::to_string(poly_config.index);

    runner.start_test(algo_name + " Basic Encryption Modes");
    try {
        test_basic_modes_with_function(key, iv, create_algo_func, algo_name);
        runner.end_test(true);
    } catch (const std::exception& e) {
        std::cout << "Exception: " << e.what() << std::endl;
        runner.end_test(false);
    }
}

void RijndaelTest::test_aes_256_with_polynomial(const TestFileConfig& config, const PolynomialConfig& poly_config) {
    std::cout << "\n--- Testing AES-256 with Polynomial " << poly_config.name << " ---" << std::endl;

    std::vector<std::byte> key(32);
    for (size_t i = 0; i < 32; ++i) {
        key[i] = static_cast<std::byte>(i + 0x40);
    }

    std::vector<std::byte> iv(16);
    for (size_t i = 0; i < 16; ++i) {
        iv[i] = static_cast<std::byte>(i + 0x50);
    }

    std::function<std::unique_ptr<symmetric_context::SymmetricAlgorithm>(const std::vector<std::byte>&)> create_algo_func =
            [&poly_config](const std::vector<std::byte>& k) {
                return create_aes_256_with_polynomial(k, poly_config);
            };

    std::string algo_name = "AES-256-poly" + std::to_string(poly_config.index);

    runner.start_test(algo_name + " Basic Encryption Modes");
    try {
        test_basic_modes_with_function(key, iv, create_algo_func, algo_name);
        runner.end_test(true);
    } catch (const std::exception& e) {
        std::cout << "Exception: " << e.what() << std::endl;
        runner.end_test(false);
    }
}

void RijndaelTest::test_with_different_polynomials(const TestFileConfig& config) {
    std::cout << "\n=== TESTING WITH DIFFERENT IRREDUCIBLE POLYNOMIALS ===" << std::endl;

    auto polynomials = get_available_polynomials();

    if (polynomials.empty()) {
        std::cout << "No irreducible polynomials available!" << std::endl;
        return;
    }

    std::cout << "Found " << polynomials.size() << " irreducible polynomial(s) for testing." << std::endl;

    for (size_t i = 0; i < polynomials.size(); ++i) {
        const auto& poly = polynomials[i];

        std::cout << "\n--- Testing with Polynomial #" << i << ": " << poly.name << " ---" << std::endl;

        runner.start_test("Basic Test with Polynomial " + poly.name);
        try {
            std::vector<std::byte> test_key(16, std::byte{0x01});
            std::vector<std::byte> test_iv(16, std::byte{0x02});

            auto algorithm = create_aes_128_with_polynomial(test_key, poly);
            symmetric_context::SymmetricContext ctx(test_key,
                                                    symmetric_context::EncryptionModes::CBC,
                                                    symmetric_context::PaddingModes::PKCS7,
                                                    test_iv, {}, std::move(algorithm));

            std::vector<std::byte> test_data = {std::byte{0x01}, std::byte{0x02},
                                                std::byte{0x03}, std::byte{0x04}};

            auto encrypted = ctx.encrypt(test_data).get();
            auto decrypted = ctx.decrypt(encrypted).get();

            runner.assert_true(compare_byte_vectors(test_data, decrypted),
                               "Encryption/decryption should work with polynomial " + poly.name);
            runner.end_test(true);
        } catch (const std::exception& e) {
            std::cout << "Exception with polynomial " << poly.name << ": " << e.what() << std::endl;
            runner.end_test(false);
        }

        test_aes_128_with_polynomial(config, poly);

        if (polynomials.size() <= 3) {
            test_aes_192_with_polynomial(config, poly);
            test_aes_256_with_polynomial(config, poly);
        }
    }
}

void RijndaelTest::run_all_rijndael_tests(const TestFileConfig& config) {
    std::cout << "\n=== RUNNING RIJNDAEL (AES) TESTS ===" << std::endl;
    std::cout << "Results will be saved in: tests/test_rijndael/results/" << std::endl;

    std::filesystem::create_directories("tests/test_rijndael/results");

    initialize_galois_fields();

    print_available_polynomials();

    runner.start_test("Basic Rijndael Algorithm Creation (Default Polynomial)");
    try {
        std::vector<std::byte> test_key(16, std::byte{0x01});

        PolynomialConfig default_poly;
        default_poly.polynomial = std::byte{0x1B};
        default_poly.index = 0;
        default_poly.name = polynomial_to_string(default_poly.polynomial);

        auto algo = create_aes_128_with_polynomial(test_key, default_poly);

        std::vector<std::byte> test_block(16, std::byte{0x00});
        auto encrypted = algo->encrypt(test_block);
        auto decrypted = algo->decrypt(encrypted);

        runner.assert_true(encrypted.size() == test_block.size(),
                           "Encrypted block should have same size as input");
        runner.assert_true(decrypted.size() == test_block.size(),
                           "Decrypted block should have same size as input");
        runner.assert_true(!compare_byte_vectors(test_block, encrypted),
                           "Encrypted data should be different from original");
        runner.assert_true(compare_byte_vectors(test_block, decrypted),
                           "Decrypted data should match original");

        runner.end_test(true);
    } catch (const std::exception& e) {
        std::cout << "Exception in basic test: " << e.what() << std::endl;
        runner.end_test(false);
        return;
    }

    test_with_different_polynomials(config);

    runner.start_test("Random Key/IV Test (Default Polynomial)");
    try {
        std::random_device rd;
        std::mt19937 gen(rd());
        std::uniform_int_distribution<> dis(0, 255);

        std::vector<std::byte> random_key(16);
        for (auto& b : random_key) b = static_cast<std::byte>(dis(gen));

        std::vector<std::byte> random_iv(16);
        for (auto& b : random_iv) b = static_cast<std::byte>(dis(gen));

        std::vector<std::byte> test_data(64);
        for (auto& b : test_data) b = static_cast<std::byte>(dis(gen));

        PolynomialConfig default_poly;
        default_poly.polynomial = std::byte{0x1B};
        default_poly.index = 0;
        default_poly.name = polynomial_to_string(default_poly.polynomial);

        auto algo = create_aes_128_with_polynomial(random_key, default_poly);
        symmetric_context::SymmetricContext ctx(random_key,
                                                symmetric_context::EncryptionModes::CBC,
                                                symmetric_context::PaddingModes::PKCS7,
                                                random_iv, {}, std::move(algo));

        auto encrypted = ctx.encrypt(test_data).get();
        auto decrypted = ctx.decrypt(encrypted).get();

        runner.assert_true(compare_byte_vectors(test_data, decrypted),
                           "Encryption/decryption with random key/IV should work");
        runner.end_test(true);
    } catch (const std::exception& e) {
        std::cout << "Exception: " << e.what() << std::endl;
        runner.end_test(false);
    }
}

void run_all_rijndael_tests_with_custom_files(
        const std::filesystem::path& text_file,
        const std::filesystem::path& binary_file,
        const std::filesystem::path& image_file,
        const std::filesystem::path& pdf_file,
        const std::filesystem::path& zip_file,
        const std::filesystem::path& mp4_file) {

    std::cout << "=== RIJNDAEL/AES TEST SUITE ===" << std::endl;
    std::cout << "==============================" << std::endl;

    TestFileConfig config;
    config.set_custom_files(text_file, binary_file, image_file, pdf_file, zip_file, mp4_file);

    if (config.has_any_files()) {
        std::cout << "\nTest files found:" << std::endl;
        config.print_available_files();
    } else {
        std::cout << "\nNo test files provided. Running basic encryption tests only." << std::endl;
    }

    TestRunner runner;
    RijndaelTest rijndael_test(runner);

    auto start_time = std::chrono::high_resolution_clock::now();

    try {
        rijndael_test.run_all_rijndael_tests(config);
    } catch (const std::exception& e) {
        std::cerr << "\nFatal error in Rijndael tests: " << e.what() << std::endl;
    }

    auto end_time = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time);

    std::cout << "\n=== RIJNDAEL TESTS COMPLETED ===" << std::endl;
    std::cout << "Total time: " << duration.count() << " ms" << std::endl;
    std::cout << "Results saved in: tests/test_rijndael/results/" << std::endl;

    runner.print_summary();
}

void run_rijndael_tests_with_polynomial_selection(
        const std::filesystem::path& text_file,
        const std::filesystem::path& binary_file,
        const std::filesystem::path& image_file,
        const std::filesystem::path& pdf_file,
        const std::filesystem::path& zip_file,
        const std::filesystem::path& mp4_file) {

    std::cout << "=== RIJNDAEL/AES TEST SUITE WITH POLYNOMIAL SELECTION ===" << std::endl;
    std::cout << "=========================================================" << std::endl;

    TestFileConfig config;
    config.set_custom_files(text_file, binary_file, image_file, pdf_file, zip_file, mp4_file);

    std::cout << "\n=== Test Files Information ===" << std::endl;
    if (config.has_any_files()) {
        config.print_available_files();

        std::cout << "\nExisting files:" << std::endl;
        auto check_file = [](const std::string& type, const std::filesystem::path& path) {
            if (!path.empty()) {
                if (std::filesystem::exists(path)) {
                    std::cout << "  ✓ " << type << ": " << path << " ("
                              << std::filesystem::file_size(path) << " bytes)" << std::endl;
                    return true;
                } else {
                    std::cout << "  ✗ " << type << ": " << path << " (NOT FOUND)" << std::endl;
                }
            }
            return false;
        };

        bool any_exists = false;
        any_exists |= check_file("Text", config.text_file_path);
        any_exists |= check_file("Binary", config.binary_file_path);
        any_exists |= check_file("Image", config.image_file_path);
        any_exists |= check_file("PDF", config.pdf_file_path);
        any_exists |= check_file("ZIP", config.zip_file_path);
        any_exists |= check_file("MP4", config.mp4_file_path);

        if (!any_exists) {
            std::cout << "\nWarning: No test files found. File tests will be skipped." << std::endl;
        }
    } else {
        std::cout << "No test files configured." << std::endl;
    }

    print_available_polynomials();

    auto polynomials = get_available_polynomials();

    if (polynomials.empty()) {
        std::cout << "No irreducible polynomials available. Running default tests." << std::endl;
        run_all_rijndael_tests_with_custom_files(text_file, binary_file, image_file,
                                                 pdf_file, zip_file, mp4_file);
        return;
    }

    std::cout << "\n=== Polynomial Selection Menu ===" << std::endl;
    std::cout << "Options:" << std::endl;
    std::cout << "  'all'     - Test all " << polynomials.size() << " polynomials" << std::endl;
    std::cout << "  'default' - Test only AES polynomial (0x1B)" << std::endl;
    std::cout << "  0-" << (polynomials.size() - 1) << "      - Test specific polynomial by index" << std::endl;
    std::cout << "  'list'    - Show polynomial list again" << std::endl;
    std::cout << "  'exit'    - Exit test" << std::endl;

    std::string choice;
    bool exit_program = false;

    while (!exit_program) {
        std::cout << "\nEnter your choice: ";
        std::cin >> choice;

        if (choice == "exit") {
            std::cout << "Exiting polynomial selection." << std::endl;
            return;
        } else if (choice == "list") {
            print_available_polynomials();
            continue;
        }

        TestRunner runner;
        RijndaelTest rijndael_test(runner);

        auto start_time = std::chrono::high_resolution_clock::now();

        try {
            if (choice == "all") {
                std::cout << "\nTesting ALL " << polynomials.size() << " irreducible polynomials..." << std::endl;

                int tested_count = 0;
                for (const auto& poly : polynomials) {
                    std::cout << "\n=== Testing Polynomial #" << poly.index << ": " << poly.name << " ===" << std::endl;
                    rijndael_test.test_aes_128_with_polynomial(config, poly);
                    tested_count++;

                    if (polynomials.size() > 10 && tested_count % 5 == 0) {
                        std::cout << "\nProgress: " << tested_count << "/" << polynomials.size()
                                  << " polynomials tested." << std::endl;
                    }
                }
                std::cout << "\nCompleted testing all " << tested_count << " polynomials." << std::endl;
            } else if (choice == "default") {
                PolynomialConfig default_poly;
                bool found_default = false;

                for (const auto& poly : polynomials) {
                    if (poly.name.find("0x1B") != std::string::npos) {
                        default_poly = poly;
                        found_default = true;
                        break;
                    }
                }

                if (!found_default) {
                    default_poly = polynomials[0];
                }

                std::cout << "\nTesting with default AES polynomial: " << default_poly.name << std::endl;
                rijndael_test.test_aes_128_with_polynomial(config, default_poly);
            } else {
                try {
                    size_t index = std::stoul(choice);
                    if (index < polynomials.size()) {
                        std::cout << "\nTesting with polynomial #" << index << ": "
                                  << polynomials[index].name << std::endl;
                        rijndael_test.test_aes_128_with_polynomial(config, polynomials[index]);
                    } else {
                        std::cout << "Invalid index. Must be between 0 and " << (polynomials.size() - 1) << std::endl;
                    }
                } catch (...) {
                    std::cout << "Invalid choice. Please enter a number, 'all', 'default', 'list', or 'exit'." << std::endl;
                }
            }
        } catch (const std::exception& e) {
            std::cerr << "\nFatal error in Rijndael tests: " << e.what() << std::endl;
        }

        auto end_time = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time);

        std::cout << "\n=== RIJNDAEL TESTS COMPLETED ===" << std::endl;
        std::cout << "Total time: " << duration.count() << " ms" << std::endl;

        runner.print_summary();

        std::cout << "\nDo you want to test another polynomial? (yes/no): ";
        std::string continue_choice;
        std::cin >> continue_choice;

        if (continue_choice != "yes" && continue_choice != "y") {
            exit_program = true;
        }
    }
}
void run_basic_rijndael_tests() {
    std::cout << "=== BASIC RIJNDAEL/AES TESTS (NO FILES) ===" << std::endl;
    std::cout << "=========================================" << std::endl;

    TestRunner runner;
    RijndaelTest rijndael_test(runner);

    TestFileConfig config;

    auto start_time = std::chrono::high_resolution_clock::now();

    try {
        rijndael_test.run_all_rijndael_tests(config);
    } catch (const std::exception& e) {
        std::cerr << "\nFatal error in basic Rijndael tests: " << e.what() << std::endl;
    }

    auto end_time = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time);

    std::cout << "\n=== BASIC RIJNDAEL TESTS COMPLETED ===" << std::endl;
    std::cout << "Total time: " << duration.count() << " ms" << std::endl;

    runner.print_summary();
}